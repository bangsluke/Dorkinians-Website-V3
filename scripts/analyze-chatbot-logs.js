#!/usr/bin/env node

/**
 * Chatbot Log Analysis Tool
 * Analyzes the log files generated by the enhanced logging test to identify patterns and issues
 */

const fs = require("fs");
const path = require("path");

// Load environment variables
require("dotenv").config();

function analyzeLogs() {
	console.log("üîç Analyzing chatbot test logs...");

	const logDir = path.join(__dirname, "..", "logs");

	if (!fs.existsSync(logDir)) {
		console.log("‚ùå Logs directory not found. Run the enhanced logging test first.");
		return;
	}

	// Find the most recent log files
	const logFiles = fs
		.readdirSync(logDir)
		.filter((file) => file.startsWith("test-execution-") && file.endsWith(".log"))
		.sort()
		.reverse();

	if (logFiles.length === 0) {
		console.log("‚ùå No test execution logs found. Run the enhanced logging test first.");
		return;
	}

	const latestLogFile = path.join(logDir, logFiles[0]);
	const errorLogFile = latestLogFile.replace("test-execution-", "test-errors-");
	const debugLogFile = latestLogFile.replace("test-execution-", "test-debug-");

	console.log(`üìù Analyzing log file: ${latestLogFile}`);

	// Read and analyze the main log file
	let logContent = fs.readFileSync(latestLogFile, "utf8");
	
	// If execution log is empty or minimal, also read error log
	if (logContent.trim().length < 100 && fs.existsSync(errorLogFile)) {
		console.log(`üìù Execution log is minimal (${logContent.trim().length} chars), also analyzing error log: ${errorLogFile}`);
		const errorContent = fs.readFileSync(errorLogFile, "utf8");
		// Prepend error log content to execution log content for analysis
		logContent = errorContent + (logContent.trim() ? "\n" + logContent : "");
	}
	
	const lines = logContent.split("\n").filter(line => line.trim().length > 0);

	// Analysis categories
	const analysis = {
		totalLines: lines.length,
		errors: [],
		warnings: [],
		apiCalls: [],
		databaseQueries: [],
		chatbotResponses: [],
		fallbacks: [],
		performance: [],
		patterns: {
			commonErrors: {},
			commonWarnings: {},
			responsePatterns: {},
			queryPatterns: {},
		},
	};

	// Analyze each line
	lines.forEach((line, index) => {
		const lineNumber = index + 1;

		// Extract timestamp and level (if present)
		const timestampMatch = line.match(/^\[([^\]]+)\]\s+(\w+):\s+(.+)$/);
		let timestamp = null;
		let level = null;
		let message = line;

		if (timestampMatch) {
			[, timestamp, level, message] = timestampMatch;
		}

		// Detect errors - lines starting with ‚ùå or containing error indicators
		const isError = level === "ERROR" || line.includes("‚ùå") || 
			line.toLowerCase().includes("error") || 
			line.toLowerCase().includes("failed") ||
			line.toLowerCase().includes("exception");

		if (isError) {
			analysis.errors.push({ lineNumber, timestamp, message });

			// Track common error patterns
			const errorKey = message
				.toLowerCase()
				.replace(/\d+/g, "N")
				.replace(/"[^"]*"/g, "STRING")
				.replace(/[^\w\s]/g, "")
				.trim()
				.substring(0, 100); // Limit length
			if (errorKey) {
				analysis.patterns.commonErrors[errorKey] = (analysis.patterns.commonErrors[errorKey] || 0) + 1;
			}
		}

		// Detect warnings
		const isWarning = level === "WARN" || line.includes("‚ö†Ô∏è") || 
			line.toLowerCase().includes("warning");

		if (isWarning) {
			analysis.warnings.push({ lineNumber, timestamp, message });

			const warningKey = message
				.toLowerCase()
				.replace(/\d+/g, "N")
				.replace(/"[^"]*"/g, "STRING")
				.replace(/[^\w\s]/g, "")
				.trim()
				.substring(0, 100);
			if (warningKey) {
				analysis.patterns.commonWarnings[warningKey] = (analysis.patterns.commonWarnings[warningKey] || 0) + 1;
			}
		}

		// Track API calls
		if (message.includes("API call") || message.includes("fetch") || 
			(message.includes("response") && message.includes("http"))) {
			analysis.apiCalls.push({ lineNumber, timestamp, message });
		}

		// Track database queries - look for Cypher keywords
		const hasCypherKeywords = /(MATCH|RETURN|WHERE|WITH|ORDER BY|LIMIT|CREATE|DELETE|SET|MERGE)/i.test(message);
		const hasQueryIndicators = message.includes("Cypher") || message.includes("Query") || 
			message.includes("Neo4j") || (message.includes("Variable") && message.includes("not defined"));

		if (hasCypherKeywords || hasQueryIndicators) {
			analysis.databaseQueries.push({ lineNumber, timestamp, message });

			// Extract query patterns
			const queryMatch = message.match(/(MATCH|RETURN|WHERE|WITH|ORDER BY|LIMIT|CREATE|DELETE|SET|MERGE)/gi);
			if (queryMatch) {
				const pattern = queryMatch.join(" ").toLowerCase();
				analysis.patterns.queryPatterns[pattern] = (analysis.patterns.queryPatterns[pattern] || 0) + 1;
			}
		}

		// Track chatbot responses - lines with ü§ñ [CLIENT] or chatbot indicators
		const isChatbotResponse = line.includes("ü§ñ") || line.includes("[CLIENT]") ||
			message.includes("Chatbot response") || 
			(message.includes("answer") && !message.includes("query"));

		if (isChatbotResponse) {
			analysis.chatbotResponses.push({ lineNumber, timestamp, message });

			// Track response patterns
			if (message.includes("I couldn't find") || message.includes("No data found") || 
				message.includes("No results found") || message.includes("No match found") ||
				message.includes("Player not found") || message.includes("error")) {
				const responseKey = message
					.toLowerCase()
					.replace(/\d+/g, "N")
					.replace(/"[^"]*"/g, "STRING")
					.replace(/[^\w\s]/g, "")
					.trim()
					.substring(0, 100);
				if (responseKey) {
					analysis.patterns.responsePatterns[responseKey] = (analysis.patterns.responsePatterns[responseKey] || 0) + 1;
				}
			}
		}

		// Track fallbacks
		if (message.includes("fallback") || message.includes("CSV") || 
			message.includes("Using API fallback")) {
			analysis.fallbacks.push({ lineNumber, timestamp, message });
		}

		// Track performance metrics
		if (/\d+ms/.test(message) || message.includes("duration") || 
			(message.includes("time") && /\d+/.test(message))) {
			analysis.performance.push({ lineNumber, timestamp, message });
		}
	});

	// Generate analysis report
	const reportSeparator = "=".repeat(50);
	console.log("\nüìä LOG ANALYSIS REPORT");
	console.log(reportSeparator);

	console.log(`\nüìà OVERVIEW:`);
	console.log(`  - Total log lines: ${analysis.totalLines}`);
	console.log(`  - Errors: ${analysis.errors.length}`);
	console.log(`  - Warnings: ${analysis.warnings.length}`);
	console.log(`  - API calls: ${analysis.apiCalls.length}`);
	console.log(`  - Database queries: ${analysis.databaseQueries.length}`);
	console.log(`  - Chatbot responses: ${analysis.chatbotResponses.length}`);
	console.log(`  - Fallbacks: ${analysis.fallbacks.length}`);

	// Most common errors
	console.log(`\n‚ùå TOP ERRORS:`);
	const topErrors = Object.entries(analysis.patterns.commonErrors)
		.sort(([, a], [, b]) => b - a)
		.slice(0, 5);
	topErrors.forEach(([pattern, count], index) => {
		console.log(`  ${index + 1}. (${count}x) ${pattern}`);
	});

	// Most common warnings
	console.log(`\n‚ö†Ô∏è TOP WARNINGS:`);
	const topWarnings = Object.entries(analysis.patterns.commonWarnings)
		.sort(([, a], [, b]) => b - a)
		.slice(0, 5);
	topWarnings.forEach(([pattern, count], index) => {
		console.log(`  ${index + 1}. (${count}x) ${pattern}`);
	});

	// Response patterns
	console.log(`\nü§ñ RESPONSE PATTERNS:`);
	const topResponsePatterns = Object.entries(analysis.patterns.responsePatterns)
		.sort(([, a], [, b]) => b - a)
		.slice(0, 5);
	topResponsePatterns.forEach(([pattern, count], index) => {
		console.log(`  ${index + 1}. (${count}x) ${pattern}`);
	});

	// Query patterns
	console.log(`\nüîç QUERY PATTERNS:`);
	const topQueryPatterns = Object.entries(analysis.patterns.queryPatterns)
		.sort(([, a], [, b]) => b - a)
		.slice(0, 5);
	topQueryPatterns.forEach(([pattern, count], index) => {
		console.log(`  ${index + 1}. (${count}x) ${pattern}`);
	});

	// Detailed error analysis
	if (analysis.errors.length > 0) {
		console.log(`\nüîç DETAILED ERROR ANALYSIS:`);
		analysis.errors.slice(0, 10).forEach((error, index) => {
			console.log(`  ${index + 1}. Line ${error.lineNumber}: ${error.message}`);
		});
	}

	// Fallback analysis
	if (analysis.fallbacks.length > 0) {
		console.log(`\nüîÑ FALLBACK ANALYSIS:`);
		console.log(`  - Total fallbacks: ${analysis.fallbacks.length}`);
		analysis.fallbacks.slice(0, 5).forEach((fallback, index) => {
			console.log(`  ${index + 1}. Line ${fallback.lineNumber}: ${fallback.message}`);
		});
	}

	// Recommendations
	console.log(`\nüí° RECOMMENDATIONS:`);

	if (analysis.errors.length > 0) {
		console.log(`  - Fix ${analysis.errors.length} errors identified in the logs`);
	}

	if (analysis.fallbacks.length > 0) {
		console.log(`  - Investigate ${analysis.fallbacks.length} fallback scenarios`);
		console.log(`  - Check database connectivity and query performance`);
	}

	if ((analysis.patterns.responsePatterns["i couldn't find"] || 0) > 0) {
		console.log(`  - Improve entity resolution for player name matching`);
	}

	if ((analysis.patterns.responsePatterns["no data found"] || 0) > 0) {
		console.log(`  - Check database data availability and query accuracy`);
	}

	// Check for undefined patterns to avoid NaN
	if (Object.keys(analysis.patterns.responsePatterns).length === 0) {
		analysis.patterns.responsePatterns = {};
	}
	if (Object.keys(analysis.patterns.queryPatterns).length === 0) {
		analysis.patterns.queryPatterns = {};
	}
	if (Object.keys(analysis.patterns.commonErrors).length === 0) {
		analysis.patterns.commonErrors = {};
	}
	if (Object.keys(analysis.patterns.commonWarnings).length === 0) {
		analysis.patterns.commonWarnings = {};
	}

	// Save detailed analysis to file
	const analysisFile = path.join(logDir, `log-analysis-${new Date().toISOString().replace(/[:.]/g, "-")}.json`);
	fs.writeFileSync(analysisFile, JSON.stringify(analysis, null, 2));
	console.log(`\nüìù Detailed analysis saved to: ${analysisFile}`);

	return analysis;
}

// Run the analysis
if (require.main === module) {
	analyzeLogs();
}

module.exports = { analyzeLogs };
